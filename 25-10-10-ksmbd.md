---
layout: post
title: "[DH] Exploit Tech: Return Oriented Programming"
categories:
  - Pwnable
tags:
  - pwn
  - dreamhack
last_modified_at: 2025-09-30
published: false
---

오늘 읽을 자료는 [https://pwning.tech/ksmbd/](https://pwning.tech/ksmbd/)
리눅스 커널의 ksmbd 부분에 대해 알아보자. 

여담으로 짚고 넘어가면 좋은 부분이 
* ZDI란? 

# ZDI-22-1690 
리눅스 커널 ksmbd 하위 시스템에 존재하는 unauthentication RCE vul이다. ksmbd는 Kernel SMB Daemon의 약자로, 커널에서 SMB server 역할을 한다(Windows에서 많이 볼 수 있다. 시스템 보안 2주차에서도 나왔던듯)

SMB 관련한 취약점은 많은데 이게 커널에 도입 되었다. 해당 post에서는 ksmbd 시스템의 취약점을 조사할 예정이다. 

ZDI-23-979
ZDI-23-980 

# SMB 
SMB는 Server Message Block의 약자로, 윈도우에서 많이 쓰는 파일 전송 프로토콜이다. SMB에서 제공하는 기능은 다음과 같다. 

1. file Read, Write 
2. Directory info access 
3. authentication 

Windows OS에서는 SMB를 통합하기 위해 Windows에서 사용하는 다양한 인증 방식을 제공한다(NTLMSSP, kerberos 5, Microsoft Kerberos 5, U2U auth) 

여기서 RAM이나 disk 저장 공간에서 resource 낭비를 방지하기 위해 credit system을 사용한다. 각 명령이 세션에서 크레딧을 차감하는 시스템 
* 원문 살펴볼 필요가 있다. 

# ZDI-23-979 : NULL pointer 역참조 DoS 

chained SMB request packet의 session 처리 과정에서 발생하는 logical bug -> NULL pointer 역참조 취약점이 발생한다. 

1. 패킷의 첫번째 요청에 대한 세션 처리 
2. 패킷의 두번째 요청도 동일한 세션 인스턴스 사용 

if 첫번째 요청에서 세션을 사용하지 않으면, 
-> 두번째 요청도 세션을 사용하지 않음 

이때 세션 auth 검사를 건너뛸 수 있어서 인증 우회가 발생할 수 있다. 그런데 post에서는 인증 우회에 대해 언급하진 않고 인증을 처리하기 위해 요청 세션의 속성에 접근 -> 근데 세션을 사용하지 않은 요청에 한해 NULL 포인터를 역참조하게 된다. 

__handle_ksmbd_work 함수
모든 패킷을 연결할 때마다 해당 함수가 호출됨 

```c
static void __handle_ksmbd_work(struct ksmbd_work *work,
				struct ksmbd_conn *conn)
{
	u16 command = 0;
	int rc;

	// [snip] (initialize buffers) 

	if (conn->ops->check_user_session) {
		rc = conn->ops->check_user_session(work);

		// if rc != 0 goto send (auth failed)
		if (rc < 0) {
			command = conn->ops->get_cmd_val(work);
			conn->ops->set_rsp_status(work,
					STATUS_USER_SESSION_DELETED);
			goto send;
		} else if (rc > 0) {
			rc = conn->ops->get_ksmbd_tcon(work);
			if (rc < 0) {
				conn->ops->set_rsp_status(work,
					STATUS_NETWORK_NAME_DELETED);
				goto send;
			}
		}
	}

	do {
		rc = __process_request(work, conn, &command);
		if (rc == SERVER_HANDLER_ABORT)
			break;

	    // [snip] (set SMB credits)
	} while (is_chained_smb2_message(work));

	if (work->send_no_response)
		return;

send:
	// [snip] (send response)
}
```

위 코드를 살펴보면 if (conn->ops->check_user_session) 으로 첫번째 요청에 대한 user_session만 확인한다. 